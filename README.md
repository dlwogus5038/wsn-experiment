<style>
@media print {    
    [data-cmd=toc] + ul {
        display: none !important;
    }
}
</style>

<h1 style="text-align:center;">WSN实验报告</h1>
<p style="text-align:center;">孙子平 2015013249 车行 2015013241 李在弦 2015080121</p>


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=4 orderedList=false} -->
<!-- code_chunk_output -->

* [1 题目一：多跳WSN数据采集](#1-题目一多跳wsn数据采集)
	* [1.1 关于](#11-关于)
		* [1.1.1 项目特色](#111-项目特色)
		* [1.1.1 目录结构](#111-目录结构)
		* [1.1.2 使用方式](#112-使用方式)
	* [1.2 实现](#12-实现)
		* [1.2.1 节点实现](#121-节点实现)
		* [1.2.2 可视化实现](#122-可视化实现)
* [2 题目二：多点协作Data Aggregation实验](#2-题目二多点协作data-aggregation实验)
	* [2.1 关于](#21-关于)
		* [2.1.1 项目特色](#211-项目特色)

<!-- /code_chunk_output -->

## 1 题目一：多跳WSN数据采集

### 1.1 关于

#### 1.1.1 项目特色

* 组网自由：可自由组网成树状的拓扑结构，支持任意数目节点组网，可视化支持任意数目节点
* 可靠传输：几乎0丢包率，即使节点掉线一阵子，重连之后，依旧不会丢包
* 实时交互的可视化界面：基于Web的可视化，实时统计丢包数目、重包数目等，统计图表可交互显示

#### 1.1.1 目录结构

项目的根目录位于`task1`下，包括以下文件、文件夹：

* `Node/`：Telosb节点的代码，我们所有的节点都采用同一份代码
  * `ForwarderC.nc`：泛型传输模块，负责在父子节点之间建立可靠传输
  * `SensorC.nc`：传感器模块，负责收集数据
  * `AppC.nc`：顶层模块
* `Visualizer/`：数据可视化的Web服务端
  * `main.py`：服务端代码
* `nodes.csv`：配置文件，用以为不同的节点产生不同的编译选项

#### 1.1.2 使用方式

首先编辑`nodes.csv`，格式如下方的表格。如果节点是`Sensor`，则会收集传感器数据；如果节点是`Base Station`，则其上游通信不是采用无线而是采用串口。

| ID | Father ID | Sensor | Base Station |
|:---:|:----:|:----:|:---:|
| 0 | 0 | 0 | 1 |
| 1 | 0 | 1 | 0 |
| 2 | 1 | 1 | 0 |

之后可以烧录程序，运行可视化界面：

```bash
cd task1
# 编译节点代码，<node_id>为节点的ID
make compile,<node_id>
# 烧录节点程序，<node_id>为节点的ID
make install,<node_id>
# 不停烧录节点程序直至成功，<node_id>为节点的ID
./FuckMake install,<node_id>
# 启用可视化，后面可跟串口参数，默认是serial@/dev/ttyUSB0:115200
python Visualizer/main.py
```

这时，可以浏览器打开`http://localhost:8050/`看到可视化的效果。这里3个节点的Sensor都开启了，所有的湿度传感器都有问题，而1号节点的光照传感器也有问题。

“刷新间隔”是指轮询服务器的间隔（实时改变），“显示时长”是下方各个表显示的x轴的范围（实时改变），“采样间隔”是每个节点的采样计时器触发的时间间隔（需要点击发送按钮改变）。

“手动刷新”用于触发一次轮询。“同步时间”会将下一匹收到的包作为新的基准时间，推测新的包的真实发送时间，应当在网络条件较好的情况下再点击。“清除数据”会清空显示的数据。

所有的图都可以缩放，查看细节数据。

`result.txt`是收到的最原始数据，注意我们始终用append模式打开这个文件。重复的包也会被记录下来。

![Visualizer](https://cdn.pbrd.co/images/GZJr77e.png)

### 1.2 实现

#### 1.2.1 节点实现

**可靠传输：** 首先，我们发送的数据包分为两类，往根节点传的数据消息和往叶节点传的控制消息。前者默认拥有512的循环队列，而后者默认拥有32的缓冲区。而后我们借助Tinyos自带的PackageAcknowledges借口确保1个数据包被成功发送，如果没成功发送则重试。整个发送等价滑窗为1的GBN。

**组网：** 组网我们采用静态的路由表，而后以编译参数的方式编译到程序中。数据发送我们都是指定接受者，而非广播。对于多个子节点的情况，我们是挨个发个去并确认收到的。

**数据采集：** 数据采集我们有两种方案，一种是等待全部采集完毕再采集下一匹（默认），另一种是有个采集队列，不必等待采集完成就发起下一次采集（解除`task1/Node/Makefile`中`RECORD_QUEUE`选项的注释即可启用）。实际证明，后者在采集速度上几乎等价于前者，呈现出来的时间则会有偏差，故不采用。实际节点采样频率在280~320ms左右。

#### 1.2.2 可视化实现

我们采用的数据可视化框架是[Dash by plotly](https://plot.ly/products/dash/)。数据采集则用的是TinyOS自带的Python SDK。具体实现上，我们启动了额外的线程专门用于串口通信。

## 2 题目二：多点协作Data Aggregation实验

### 2.1 关于

#### 2.1.1 项目特色
